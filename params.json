{
  "name": "Typestore",
  "tagline": "DynamoDB TypeScript Mapper & Manager",
  "body": "TypeStore\r\n---\r\n_Statically typed model persistence for TypeScript, totally pluggable_\r\n\r\n[![Circle CI](https://circleci.com/gh/densebrain/typestore/tree/master.svg?style=shield)](https://circleci.com/gh/densebrain/typestore/tree/master)\r\n\r\n\r\n_TypeStore_ by itself won't get you very far, you'll\r\nneed a store to persist your data too.  Implementing a store is\r\nreally simple in-case you don't one of the out of the box\r\nstores that already exist.\r\n\r\nInstallation\r\n---\r\n\r\n#### Install (Core)\r\n_note: reflect-meta-data package is required_\r\n\r\n```bash\r\nnpm i --save typestore\r\n```\r\n\r\n#### Install Plugin (Storage - DynamoDB)\r\n\r\nfor the sake of this example lets use AWS DynamoDB\r\n\r\n```bash\r\nnpm i --save typestore-plugin-dynamodb\r\n```\r\n\r\n#### Another Plugin (Indexing - CloudSearch)\r\n\r\nAs an example of how far you can take this - let's drop\r\nin cloudsearch.\r\n\r\n```bash\r\nnpm i --save typestore-plugin-cloudsearch\r\n```\r\n\r\nUsage\r\n---\r\n\r\nThis is going to be short for now\r\n\r\n#### Setup a Model + Repo\r\n\r\n**Model+Repo.ts**\r\n```javascript\r\nimport 'reflect-metadata'\r\nimport {\r\n\tPromise,\r\n\tLog,\r\n\tRepo,\r\n\tDecorations,\r\n\tTypes,\r\n\tModelDescriptor,\r\n\tAttributeDescriptor,\r\n\tRepoDescriptor,\r\n\tFinderDescriptor\r\n} from 'typestore'\r\n\r\n// You can extend DefaultModel, but that's up to you -\r\n// as long as you adhere to the IModel interface the system wont care\r\n@ModelDescriptor({tableName:'testTable1'})\r\nclass MyModel extends DefaultModel {\r\n\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t}\r\n\r\n\t@AttributeDescriptor({name:'id',hashKey:true})\r\n    id:string\r\n\r\n    @AttributeDescriptor({name:'createdAt',rangeKey:true})\r\n    createdAt:number\r\n\r\n\r\n    @AttributeDescriptor({\r\n        name:'randomText',\r\n        index:{\r\n            name: 'RandomTextIndex'\r\n        }\r\n    })\r\n    randomText:string\r\n}\r\n\r\n@RepoDescriptor()\r\nexport class MyRepo extends Repo<MyModel> {\r\n\r\n\tconstructor() {\r\n\t\tsuper(MyModelRepo,MyModel)\r\n\t}\r\n\r\n\t@DynamoDBFinderDescriptor({\r\n\t\tqueryExpression: \"randomText = :randomText\",\r\n\t\tindex: 'RandomTextIndex',\r\n\t\t// values could be ['randomText'] with the same effect\r\n\t\tvalues: function(...args) {\r\n\t\t\treturn {\r\n\t\t\t\t':randomText': args[0]\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\t@FinderDescriptor()\r\n\tfindByRandomText(text:string):Promise<MyModel[]> {\r\n\t\t// Finders can be totally empty\r\n\t\t// The Repo will replace the method\r\n\t\t// If TSC emitted abstracted classes\r\n\t\t// or interfaces then no body would be\r\n\t\t// needed at all\r\n\t\treturn null\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\n#### Initialize and use it\r\n\r\n```javascript\r\n\r\nimport {Manager} from 'typestore'\r\nimport {DynamoDBStore} from 'typestore-plugin-dynamodb'\r\nimport {MyModel,MyRepo} from './Model+Repo'\r\n\r\nconst store = new DynamoDBStore()\r\n\r\n// Used for DynamoDB Local - Obviously not needed for the real thing\r\nconst DynamoDBLocalEndpoint = 'http://localhost:8000'\r\n\r\nconst opts:IDynamoDBManagerOptions = {\r\n\r\n\t//Dynamo store specific options\r\n\tdynamoEndpoint: DynamoDBLocalEndpoint,\r\n\r\n\t// Add a prefix to my tables\r\n\tprefix: `dev_`,\r\n\r\n\t// Automatically create tables/models if\r\n\t// they dont exist\r\n\tsyncStrategy: SyncStrategy.Update,\r\n\r\n\t// The actual store\r\n\tstore\r\n}\r\n\r\nManager.init(opts)\r\n\t.then(() => {\r\n\t\t// Pass your models in as REST args\r\n\t\tManager.start(MyModel)\r\n\t})\r\n\r\n// All of the Promise infrastructure used is\r\n// bluebird - SO - if you want to get jiggy with it\r\n// you could do something like this\r\n\r\nManager.init(opts).call('start',MyModel)\r\n\r\n\r\n// Its all ready to go\r\nconst model = new MyModel()\r\nmodel.id = '123124'\r\nmodel.createdAt = new Date().getTime()\r\nmodel.randomText = 'asdfasdfadsf'\r\n\r\nconst repo = Manager.getRepo(MyRepo)\r\n\r\n// Save the model - create/update are synonymous in\r\n// TypeStore - so only save matters\r\nrepo.save(model)\r\n\t.then(() =>  repo.get(repo.key(model.id)))\r\n\t.then((sameModel) => {\r\n\t\tif (sameModel.id !== model.id)\r\n\t\t\tthrow new Error('You did something WRONG - naughty!')\r\n\r\n\t\treturn repo.findByRandomTest(model.randomText)\r\n\t})\r\n\t.then((finderModels) => {\r\n        if (finderModels.length !== 1 || finderModels[0].id !== model.id)\r\n            throw new Error('You did something WRONG - naughty!')\r\n\r\n        return repo.remove(repo.key(model.id))\r\n    })\r\n    .then(() => repo.findByRandomTest(model.randomText))\r\n    .then((finderModels) => {\r\n\t\tif (finderModels.length !== 0)\r\n\t        throw new Error('You did something WRONG - naughty!')\r\n\t})\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}